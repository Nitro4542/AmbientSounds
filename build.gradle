plugins {
    id 'java'
    id 'net.darkhax.curseforgegradle' version '1.1.+'
}

group 'team.creative'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
}

test {
    useJUnitPlatform()
}

java.toolchain.languageVersion = JavaLanguageVersion.of(21)

import groovy.json.*

gradle.afterProject { project ->
    if (project != rootProject) {
        project.tasks.getByName("processResources") {
            outputs.upToDateWhen { false }
            filesMatching('pack.mcmeta') {
                def input = openJsonFile(getFile())
                processJson([description: project.mod_name + " resources", pack_format: resource_pack_format,
                "forge:resource_pack_format": resource_pack_format, "forge:data_pack_format": data_pack_format], input)
                saveJsonFile(input, getFile())
            }
            filesMatching('fabric.mod.json') {
                def input = openJsonFile(getFile())
                processJson([id: project.mod_id, version: project.mod_version, name: project.mod_name, description: project.mod_description,
                license: project.mod_license, icon: project.mod_id + ".png", fabricloader: loader_version_range, "fabric-api": "*", minecraft: minecraft_version_range], input)
                if (project.hasProperty("modDependencies")) {
                    project.modDependencies.each {
                        dependency -> {
                            input["depends"][dependency.key] = dependency.value
                        }
                    }                    
                }
                saveJsonFile(input, getFile())
            }
        }
        
        project.java.withSourcesJar()
        
        def modFilePrefix = "FABRIC"
        if (project.hasProperty("mod_release_suffix") && project.mod_release_suffix != "") {
            modFilePrefix = project.mod_release_suffix
        }
        
        project.remapJar {
            archiveFileName.set(project.mod_name + "_" + modFilePrefix + "_v" + project.mod_version + "_mc" + project.minecraft_version + ".jar")
        }
        
        project.sourcesJar {
            exclude('assets/*')
            exclude('data/*')
            archiveFileName.set(project.mod_name + "_" + modFilePrefix + "_SOURCE_v" + project.mod_version + "_mc" + project.minecraft_version + ".jar")
        }
        
        project.remapSourcesJar {
            archiveFileName.set(project.mod_name + "_" + modFilePrefix + "_SOURCE_v" + project.mod_version + "_mc" + project.minecraft_version + ".jar")
        }
        
        project.jar {
            from("LICENSE") {
                rename { "${it}" }
            }
        }
        
        project.loom.runConfigs.configureEach {
            ideConfigGenerated = true
            vmArgs "-Dfabric.debug.replaceVersion=${project.mod_id}:${project.mod_version}"
        }
        
        project.java.toolchain.languageVersion = JavaLanguageVersion.of(21)
        def targetJavaVersion = 21
        project.tasks.withType(JavaCompile).configureEach {
            it.options.encoding = "UTF-8"
            if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
                it.options.release = targetJavaVersion
            }
        
            options.compilerArgs += ["-Xmaxerrs", "1000"];
        }
        
        project.java {
            def javaVersion = JavaVersion.toVersion(targetJavaVersion)
            if (JavaVersion.current() < javaVersion) {
                toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
            }
        }
        
        project.tasks.register('upload', GradleBuild) {
            description 'Uploads new version to modrinth and curseforge.'
            group = 'publishing'
            tasks = ['curseforge','modrinth']
        }
        
        project.gradle.taskGraph.whenReady {
            if (it.hasTask(project.tasks.modrinth) || it.hasTask(project.tasks.curseforge)) {
                if (!getChangelogText(project)?.trim()) {
                    throw new GradleException('No changelog provided')
                }
            }
        }
        
        project.tasks.modrinth.enabled = System.getenv("MODRINTH_TOKEN") != null
        project.tasks.modrinth.group = 'publishing'
        project.modrinth {
            token = System.getenv("MODRINTH_TOKEN")
            if (project.hasProperty("modrinth_id")) {
                projectId = project.modrinth_id
            } else {
                projectId = project.mod_id
            }
            versionNumber = project.mod_version
            versionType = project.release_type
            uploadFile = project.remapJar
            gameVersions = [ project.minecraft_version ]
            changelog = getChangelogText(project)
            dependencies {
                required.project "fabric-api"
                if (project.hasProperty("modDependencies")) {
                    project.modDependencies.each {
                        dependency -> {
                            required.project dependency.key
                        }
                    }                    
                }
            }
            additionalFiles = [ project.sourcesJar ]
        }
        
        project.tasks.register("curseforge", net.darkhax.curseforgegradle.TaskPublishCurseForge) {
            group = 'publishing'
            apiToken = System.getenv("CURSEFORGE_TOKEN") != null ? System.getenv("CURSEFORGE_TOKEN") : "empty"
            disableVersionDetection()
            
            def mainFile = upload(project.curse_id, project.remapJar)
            mainFile.releaseType = project.release_type
            mainFile.changelog = getChangelogText(project)
            mainFile.changelogType = 'markdown'
            mainFile.addModLoader("Fabric")
            mainFile.addGameVersion(project.minecraft_version)
            if (project.hasProperty("modSides") && project.modSides instanceof List && !project.modSides.isEmpty()) {
                project.modSides.each {
                    side -> {
                        mainFile.addEnvironment(side)
                    }
                }
            } else {
                mainFile.addEnvironment("client", "server")
            }
            if (project.hasProperty("modDependencies") && project.modDependencies instanceof List && !project.modDependencies.isEmpty()) {
                project.modDependencies.each {
                    key, dependency -> {
                        mainFile.addRequirement(key)
                    }
                }
            }
            
            def sourcesFile = mainFile.withAdditionalFile(project.sourcesJar)
            sourcesFile.changelog = getChangelogText(project)
            sourcesFile.changelogType = 'markdown'
        }
    }
}

String getChangelogText(project) {
    String result = ''
    boolean first = true
    project.file('changelog.txt').readLines().find {
        if (first) {
            if (it.equals(project.mod_version)) {
                first = false
            }
            return false
        } else if (!it?.trim()) {
            return true
        } else {
            result += "* " + it + "\n"
            return false
        }
    }
    
    return result
}

Object openJsonFile(file) {
    String fileContents = file.text.replaceAll(/\$\{[^}]*\}/, "0")
    def input = new JsonSlurper().parseText(fileContents)
    return input
}

void saveJsonFile(input, file) {
    BufferedWriter writer = new BufferedWriter(new FileWriter(file));
    writer.write(JsonOutput.prettyPrint(JsonOutput.toJson(input)).replace("\n", "\r\n"));
    writer.close();
}

void processJson(properties, object) {
    object.each {
        entry -> {
            if(entry.value instanceof Map) {
                processJson(properties, entry.value)
            } else if(properties.keySet().contains(entry.key)) {
                entry.value = properties.get(entry.key)
                if(entry.value.isNumber()) {
                    entry.value = entry.value.toInteger()
                }
            }
        }
    }
}